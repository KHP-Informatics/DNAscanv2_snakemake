configfile: "config.yaml"

import os
import os.path
import sys
import glob
import gzip
import bgzip

#INPUT OPTIONS
##bam, cram, fastq and vcf options
format = config["INPUT_FORMAT"]
sample_name = config["SAMPLE_NAMES"]
alsgenescanner = config["ALSGENESCANNER"]
reference = config["REFERENCE_VERSION"]
paired = config["READ_TYPE"]
input_dir = config["INPUT_FILE_DIR"]
vcf = config["ADDITIONAL_VCF_FILE_DIR"]
filter_string = config["FILTER_VARIANTS"]
debug = config["DEBUG"]
exome = config["EXOME"]
BED = config["USE_BED"]
use_gene_list = config["USE_GENE_LIST_TO_GENERATE_BED"]
RG = config["ADD_READ_GROUP"]
rm_dup = config["REMOVE_DUPLICATES"]
memory = config["MEM_GB"] * 1000

#MAIN OUTPUT DIRECTORIES
results_dir = config["OUT_DIR"]
log_dir = config["OUT_DIR"] + "logs/"
reports_dir = config["OUT_DIR"] + "reports/"
results_dir = config["OUT_DIR"] + "results/"

#OPTIONS
alignment = config["ALIGNMENT"]
variantcalling = config["SNP_INDEL"]
SV = config["STRUCTURAL_VARIANT"]
expansion = config["EXPANSION"]
STR = config["SHORT_TANDEM_REPEAT"]
genotypeSTR = config["genotype_SHORT_TANDEM_REPEAT"]
MEI = config["MOBILE_ELEMENT_INSERTION"]
annotation = config["ANNOTATION"]
annovar_protocols = config["ANNOVAR_PROTOCOLS"]
annovar_operations = config["ANNOVAR_OPERATIONS"]
sequencing_report = config["SEQUENCING_REPORT"]
alignment_report = config["ALIGNMENT_REPORT"]
calls_report = config["SNP_INDEL_CALLS_REPORT"]
results_report = config["ANNOTATION_RESULTS_REPORT"]
virus = config["VIRUS"]
bacteria = config["BACTERIA"]
custom_microbes = config["CUSTOM_MICROBES"]
RG_ID = config["ID"]
RG_LB = config["LIBRARY"]
RG_PL = config["PLATFORM"]
RG_PU = config["PLATFORM_UNIT"]
RG_SM = config["SAMPLE"]

#PATHS
path_bed = config["BED_FILE"]
path_gene_list = config["GENE_LIST"]
path_reference = config["REFERENCE_FILE"]
path_melt = config["MELT_DIR"]

#FILES FOR REFERENCE VERSIONS BASED ON ANALYSIS OPTIONS

if reference == "hg19" or reference == "grch37":
    path_expansionHunter_catalog = "resources/repeats/hg19_variant_catalog.json"
    path_delly_exclude_regions = "resources/delly_hg19.excl.tsv"
    melt_zipped_files = path_melt + "me_refs/1KGP_Hg19/*zip"
    melt_bed = path_melt + "add_bed_files/1KGP_Hg19/hg19.genes.bed"
    annovar_ref_version = "hg19"
    annotsv_ref_version = "GRCh37"
    if alsgenescanner == "true":
        path_bed = "resources/alsgenescanner/als_gene_scanner_hg19.bed"
    if reference == "grch37":
        os.system("zcat resources/exome_hg19.bed.gz | sed 's/chr//g' | bgzip -c > resources/exome_grch37.bed.gz")
        os.system("zcat resources/hg19_gene_db.txt.gz | sed 's/chr//g' | bgzip -c > resources/grch37_gene_db.txt.gz")
        os.system("cp resources/hg19_gene_names.txt.gz resources/grch37_gene_names.txt.gz")


if reference == "hg38" or reference == "grch38":
    path_expansionHunter_catalog = "resources/repeats/hg38_variant_catalog.json"
    path_delly_exclude_regions = "resources/delly_hg38.excl.tsv"
    melt_zipped_files = path_melt + "me_refs/Hg38/*zip"
    melt_bed = path_melt + "add_bed_files/Hg38/Hg38.genes.bed"
    annovar_ref_version = "hg38"
    annotsv_ref_version = "GRCh38"
    if alsgenescanner == "true":
        path_bed = "resources/alsgenescanner/als_gene_scanner_hg38.bed"
    if reference == "grch38":
        os.system("zcat resources/exome_hg38.bed.gz | sed 's/chr//g' | bgzip -c > resources/exome_grch38.bed.gz")
        os.system("zcat resources/hg38_gene_db.txt.gz | sed 's/chr//g' | bgzip -c > resources/grch38_gene_db.txt.gz")
        os.system("cp resources/hg38_gene_names.txt.gz resources/grch38_gene_names.txt.gz")

variant_results_file = ""

if format == "vcf":
    variant_results_file = input_file

    if not vcf:
        vcf = variant_results_file

#ADAPTING INPUT FILE FORMATS - unsure about how to get this
if format == "fastq":
    input_files = expand(input_dir + "{sample}.1.fq.gz", sample=sample_name) + expand(input_dir + "{sample}.2.fq.gz", sample=sample_name)
    input_file = input_dir + "{sample}.1.fq.gz"
    if paired == "paired":
        input_file2 = input_dir + "{sample}.2.fq.gz"
if format == "sam":
    input_files = expand(input_dir + "{sample}.sam", sample=sample_name)
if format == "bam":
    input_files = expand(input_dir + "{sample}.bam", sample=sample_name)
    input_file = input_dir + "{sample}.bam"
    bam_file = input_file
if format == "cram":
    input_files = expand(input_dir + "{sample}.cram", sample=sample_name)
    input_file = input_dir + "{sample}.bam"
    bam_file = input_file
if format == "vcf":
    input_files = expand(input_dir + "{sample}.vcf.gz", sample=sample_name)

if alsgenescanner == "true":
    annovar_protocols = "refGene,dbnsfp33a,clinvar_20210501,intervar_20180118"
    annovar_operations = "g,f,f,f"
    path_gene_list = ""
    BED = "true"
    alignment = "true"
    variantcalling = "true"
    annotation = "true"
    expansion = "true"
    SV = "true"

if rm_dup == "true":
    if exome == "true":
        samblaster_cmq = "samblaster --ignoreUnmated |"
    else:
        samblaster_cmq = "samblaster |"
        samblaster_bwa = "samblaster --ignoreUnmated |"

if config["USE_OWN_TEMP_DIR"] == "true":
    tmp_dir = config["TEMPORARY_DIR"]
else:
    tmp_dir = results_dir + "/tmp"

if RG:
    rg_option_hisat2 = " --rg-id %s --rg LB:%s --rg PL:%s --rg PU:%s --rg SM:%s" % (RG_ID, RG_LB, RG_PL, RG_PU, RG_SM)
    rg_option_bwa = " -R '@RG\\tID:%s\\tLB:%s\\tPL:%s\\tPU:%s\\tSM:%s' " % (RG_ID, RG_LB, RG_PL, RG_PU, RG_SM)
else:
    rg_option_hisat2 = ""
    rg_option_bwa = ""

rule all:
    input:
        expand(results_dir + "{sample}/custom.bed", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_sorted_aligned.bam", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_sorted_aligned.bam.bai", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_sorted.bam", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_sorted.bam.bai", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_delly.bam", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_delly.bam.bai", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_sorted.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_sorted.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_sorted_filtered.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_sorted_filtered.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_expansions.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_expansions.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_expansiondenovo.str_profile.json", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_genotypeSTRinput.txt", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_EHDN_variant_catalog.json", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_EHDNexpansions.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_EHDNexpansions.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_merged_SV.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_merged_SV.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_MEI.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_MEI.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_SV_MEI.merged.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_SV_MEI.merged.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/unaligned_reads.fastq.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_virus_stats.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_virus_report.txt", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_bacteria_stats.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_bacteria_report.txt", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_microbes_stats.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_microbes_report.txt", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_SNPindel_annotated.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_SNPindel_annotated.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_expansions_annotated.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_expansions_annotated.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_STR_annotated.vcf.gz", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_STR_annotated.vcf.gz.tbi", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_SV_annotated.tsv", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_MEI_annotated.tsv", sample=sample_name) +
        expand(results_dir + "{sample}/{sample}_SV_MEI_annotated.tsv", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_alignment_flagstat.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_alignment_stats.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_sequencing_report.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_calls_vcfstats.txt", sample=sample_name) +
        expand(reports_dir + "multiqc_report.html", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_annovar_SNPindel.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_annovar_expansions.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_annovar_STR.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_SV_MEI_annotated.html", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_SV_annotated.html", sample=sample_name) +
        expand(reports_dir + "{sample}/{sample}_MEI_annotated.html", sample=sample_name) +
        #expand(reports_dir + "{sample}/{sample}_all_variants.tsv", sample=sample_name) +
        expand(reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_all.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_alsod.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_clinvar.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_manual_review.txt", sample=sample_name) +
        expand(reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_all_ranked.txt", sample=sample_name)

rule custombed:
    input:
        path_gene_list
    output:
        matched_genes = results_dir + "{sample}/matched_genes.txt",
        unmatched_genes = results_dir + "{sample}/unmatched_genes.txt",
        matched_genes_codes = results_dir + "{sample}/matched_genes_codes.txt",
        custom_temp = results_dir + "{sample}/custom_tmp.bed",
        custom_sorted = results_dir + "{sample}/custom_sorted.bed",
        custom_bed = results_dir + "{sample}/custom.bed",
    params:
        path_gene_list= config["GENE_LIST"],
        use_list=config["USE_GENE_LIST_TO_GENERATE_BED"],
    conda:
        "envs/bedtools.yaml"
    log:
        log_dir + "custombed.log"
    threads: config["NUMBER_CPU"]
    resources:
        mem_mb = memory
    run:
        if params.use_list == "True" and params.path_gene_list != "":
            shell("""
                zgrep -iwf {input[0]} resources/{config[REFERENCE_VERSION]}_gene_names.txt.gz | awk '{{print $2}}' > {output.matched_genes}
                zgrep -viwf {output.matched_genes} {input[0]} > {output.unmatched_genes}
                zgrep -iwf {input[0]} resources/{config[REFERENCE_VERSION]}_gene_names.txt.gz | awk '{{print $1}}' > {output.matched_genes_codes}
                zgrep -wf {output.matched_genes_codes} resources/{config[REFERENCE_VERSION]}_gene_db.txt | awk '{{i=1; while (i<= int($8)) {n=split($9,a,/,/);n=split($10,b,/,/); print $2\"\t\"a[i]\"\t\"b[i]; i+=1}}}' > {output.custom_temp}
                bedtools sort -i {output.custom_temp} > {output.custom_sorted}
                bedtools merge -i {output.custom_sorted} > {output.custom_bed}
                rm {output.custom_sorted} {output.custom_temp}
                """)

            path_bed = results_dir + "{sample}/custom.bed"

rule alignment:
    input:
        fastq1 = input_file,
        fastq2 = input_file2
    output:
        bam_file = results_dir + "{sample}/{sample}_sorted_aligned.bam",
        bam_file_index = results_dir + "{sample}/{sample}_sorted_aligned.bam.bai"
    params:
        format = {config[FORMAT]},
        alignment = {config[ALIGNMENT]},
        paired = {config[PAIRED]},
        variantcalling = {config[SNP_INDEL]},
        SV = {config[STRUCTURAL_VARIANT]},
        MEI = {config[MOBILE_ELEMENT_INSERTION]},
        STR = {config[SHORT_TANDEM_REPEAT]},
        genotypeSTR = {config[genotype_SHORT_TANDEM_REPEAT]},
        expansion = {config[EXPANSION]},
        hisat2_bam = results_dir + "{sample}/{sample}_hisat2.bam",
        unaligned_reads = results_dir + "{sample}/{sample}_unaligned_reads.fq",
        bwa_bam = results_dir + "{sample}/{sample}_bwa.bam",
        header = results_dir + "{sample}/header.txt",
        sample = "{sample}",
        out_dir = results_dir,
        rg_hisat2 = rg_option_hisat2,
        rg_bwa = rg_option_bwa
    conda:
        "envs/alignmentfast.yaml"
    resources:
        mem_mb = memory
    log:
        log_dir + "alignmentSNPindel.log"
    run:
        if params.format == "fastq" and params.alignment == "true":
            if params.variantcalling and (params.SV or params.MEI or params.STR or params.genotypeSTR or params.expansion) == "false":
                if params.paired == "paired":
                    shell("""
                    hisat2 {config[HISAT_CUSTOM_OPTIONS]} --no-spliced-alignment -p {config[NUMBER_CPU]} -x {config[HISAT2_INDEX]} -1 {input.fastq1} -2 {input.fastq2} | {samblaster_cmq} samtools view -@ {config[NUMBER_CPU]} -Sb - | sambamba sort -t {config[NUMBER_CPU]} --tmpdir={tmp_dir} -o {output.bam_file} /dev/stdin
                    samtools index -@ {config[NUMBER_CPU]} {output.bam_file}
                    """)
                else:
                    shell("""
                    hisat2 {config[HISAT_CUSTOM_OPTIONS]} --no-spliced-alignment -p {config[NUMBER_CPU]} -x {config[HISAT2_INDEX]} -U {input[0]} | {samblaster_cmq} samtools view -@ {config[NUMBER_CPU]} -Sb - | sambamba sort -t {config[NUMBER_CPU]} --tmpdir={tmp_dir} -o {output.bam_file} /dev/stdin
                    samtools index -@ {config[NUMBER_CPU]} {output.bam_file}
                    """)
            if params.variantcalling and (params.SV or params.MEI or params.STR or params.genotypeSTR or params.expansion) == "true":
                if params.paired == "paired":
                    shell("""
                    hisat2 {config[HISAT_CUSTOM_OPTIONS]} {params.rg_hisat2} --no-softclip --no-spliced-alignment -p {config[NUMBER_CPU]} -x {config[HISAT2_INDEX]} -1 {input.fastq1} -2 {input.fastq2} | {samblaster_cmq} samtools view -@ {config[NUMBER_CPU]} -Sb - | sambamba sort -t {config[NUMBER_CPU]} --tmpdir={tmp_dir} -o {params.hisat2_bam} /dev/stdin
                    samtools index -@ {config[NUMBER_CPU]} {params.hisat2_bam}
                    samtools view -@ {config[NUMBER_CPU]} -bhf 4 {params.hisat2_bam} | samtools bam2fq - > {params.unaligned_reads}
                    bwa mem {config[BWA_CUSTOM_OPTIONS]} {params.rg_bwa} -t {config[NUMBER_CPU]} {config[BWA_INDEX]} {params.unaligned_reads} | {samblaster_bwa} samtools view -@ {config[NUMBER_CPU]} -Sb - | sambamba sort -t {config[NUMBER_CPU]} --tmpdir={tmp_dir} -o {params.bwa_bam} /dev/stdin
                    samtools index -@ {config[NUMBER_CPU]} {params.bwa_bam}
                    samtools view -H {params.hisat2_bam} > {params.header}
                    samtools merge -c -@ {config[NUMBER_CPU]} -f -h {params.header} {output.bam_file} {params.hisat2_bam} {params.bwa_bam}
                    rm {params.unaligned_reads} {params.header} {params.hisat2_bam} {params.bwa_bam} {params.out_dir}{params.sample}/{params.sample}_hisat2.bam.bai {params.out_dir}{params.sample}/{params.sample}_bwa.bam.bai
                    samtools index -@ {config[NUMBER_CPU]} {output.bam_file}
                    """)

                else:
                    shell("""
                    hisat2 {config[HISAT_CUSTOM_OPTIONS]} {params.rg_hisat2} --no-softclip --no-spliced-alignment -p {config[NUMBER_CPU]} -x {config[HISAT2_INDEX]} -1 {input.fastq1} -2 {input.fastq2} | {samblaster_cmq} samtools view -@ {config[NUMBER_CPU]} -Sb - | sambamba sort -t {config[NUMBER_CPU]} --tmpdir={tmp_dir} -o {params.hisat2_bam} /dev/stdin
                    samtools index -@ {config[NUMBER_CPU]} {params.hisat2_bam}
                    samtools view -@ {config[NUMBER_CPU]} -bhf 4 {params.hisat2_bam} | samtools bam2fq - > {params.unaligned_reads}
                    bwa mem {config[BWA_CUSTOM_OPTIONS]} {params.rg_bwa} -t {config[NUMBER_CPU]} {config[BWA_INDEX]} {params.unaligned_reads} | {samblaster_bwa} samtools view -@ {config[NUMBER_CPU]} -Sb - | sambamba sort -t {config[NUMBER_CPU]} --tmpdir={tmp_dir} -o {params.bwa_bam} /dev/stdin
                    samtools index -@ {config[NUMBER_CPU]} {params.bwa_bam}
                    samtools view -H {params.hisat2_bam} > {params.header}
                    samtools merge -c -@ {config[NUMBER_CPU]} -f -h {params.header} {output.bam_file} {params.hisat2_bam} {params.bwa_bam}
                    rm {params.unaligned_reads} {params.header} {params.hisat2_bam} {params.bwa_bam} {params.out_dir}{params.sample}/{params.sample}_hisat2.bam.bai {params.out_dir}{params.sample}/{params.sample}_bwa.bam.bai
                    samtools index -@ {config[NUMBER_CPU]} {output.bam_file}
                    """)

rule sam2bam:
        input:
            input_file = input_dir + "{sample}.sam"
        output:
            bam_file = results_dir + "{sample}/{sample}_sorted.bam",
            bam_file_index = results_dir + "{sample}/{sample}_sorted.bam.bai"
        params:
            format = {config[FORMAT]}
        conda:
            "envs/samtools.yaml"
        log:
            log_dir + "samtobam.log"
        resources:
            mem_mb = memory
        run:
            if params.format == "sam":
                shell("""
                samtools view -Sb {input[0]} > {output.bam_file}
                samtools index -@ {config[NUMBER_CPU]} {output.bam_file}
                """)

rule variantcalling:
    input:
        bam_file,
        path_bed,
        path_reference
    output:
        variant_results_file = results_dir + "{sample}/{sample}_sorted_filtered.vcf.gz" if config[FILTER_VARIANTS] == "true" else results_dir + "{sample}/{sample}_sorted.vcf.gz",
        variant_results_file_index = results_dir + "{sample}/{sample}_sorted_filtered.vcf.gz.tbi" if config[FILTER_VARIANTS] == "true" else results_dir + "{sample}/{sample}_sorted.vcf.gz.tbi"
    conda:
        "envs/variantcalling.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        variantcalling = {config[SNP_INDEL]},
        exome = {config[EXOME]},
        paired = {config[PAIRED]},
        use_bed = {config[USE_BED]},
        filter_string = {config[FILTER_VARIANTS]},
        temp_bed = results_dir + "{sample}/temp.bed.gz",
        sorted_bed = results_dir + "{sample}/sorted.bed.gz"
    log:
        log_dir + "variantcalling.yaml"
    resources:
        mem_mb = memory
    run:
        if params.variantcalling == "true":
            if params.filter_string == "true" and params.paired == "paired":
                shell("""
                {config[STRELKA_DIR]}bin/configureStrelkaGermlineWorkflow.py --bam {input[0]} --referenceFasta {input[1]} --runDir {params.out_dir}/{params.sample}/strelka
                {params.out_dir}{params.sample}/strelka/runWorkflow.py -j {config[NUMBER_CPU]} -m local
                mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz {output.variant_results_file_unfiltered}
                mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz.tbi {output.variant_results_file_unfiltered_index}
                rm -r {params.out_dir}{params.sample}/strelka
                bcftools filter -i '{config[VARIANT_FILTER_STRING]}' {input[0]} | bgzip -c > {output.variant_results_file_filtered} ; tabix -fp vcf {output.variant_results_file_filtered}
                """)
                if exome == "true":
                    shell("""
                    {config[STRELKA_DIR]}bin/configureStrelkaGermlineWorkflow.py --bam {input[0]} --referenceFasta {input[1]} --runDir {params.out_dir}/{params.sample}/strelka --exome
                    {params.out_dir}{params.sample}/strelka/runWorkflow.py -j {config[NUMBER_CPU]} -m local
                    mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz {output.variant_results_file_unfiltered}
                    mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz.tbi {output.variant_results_file_unfiltered_index}
                    bcftools filter -i '{config[VARIANT_FILTER_STRING]}' {input[0]} | bgzip -c > {output.variant_results_file_filtered} ; tabix -fp vcf {output.variant_results_file_filtered}
                    """)
                    if params.use_bed == "true":
                        shell("""
                        bgzip -c {input[1]} > {params.temp_bed}
                        sortBed -i {params.temp_bed} | bgzip -c > {params.sorted_bed}
                        tabix -p bed {params.sorted_bed}
                        {config[STRELKA_DIR]}bin/configureStrelkaGermlineWorkflow.py --bam {input[0]} --referenceFasta {input[2]} --runDir {params.out_dir}/{params.sample}/strelka --callRegions {params.sorted_bed}
                        {params.out_dir}{params.sample}/strelka/runWorkflow.py -j {config[NUMBER_CPU]} -m local
                        mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz {output.variant_results_file_unfiltered}
                        mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz.tbi {output.variant_results_file_unfiltered_index}
                        bcftools filter -i '{config[VARIANT_FILTER_STRING]}' {input[0]} | bgzip -c > {output.variant_results_file_filtered} ; tabix -fp vcf {output.variant_results_file_filtered}
                        """)

            else:
                if params.paired == "paired":
                    shell("""
                    {config[STRELKA_DIR]}bin/configureStrelkaGermlineWorkflow.py --bam {input[0]} --referenceFasta {input[1]} --runDir {params.out_dir}/{params.sample}/strelka
                    {params.out_dir}{params.sample}/strelka/runWorkflow.py -j {config[NUMBER_CPU]} -m local
                    mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz {output.variant_results_file_unfiltered}
                    mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz.tbi {output.variant_results_file_unfiltered_index}
                    rm -r {params.out_dir}{params.sample}/strelka
                    """)

                    if exome == "true":
                        shell("""
                        {config[STRELKA_DIR]}bin/configureStrelkaGermlineWorkflow.py --bam {input[0]} --referenceFasta {input[1]} --runDir {params.out_dir}/{params.sample}/strelka --exome
                        {params.out_dir}{params.sample}/strelka/runWorkflow.py -j {config[NUMBER_CPU]} -m local
                        mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz {output.variant_results_file_unfiltered}
                        mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz.tbi {output.variant_results_file_unfiltered_index}
                        """)
                        if params.use_bed == "true":
                            shell("""
                            bgzip -c {input[1]} > {params.temp_bed}
                            sortBed -i {params.temp_bed} | bgzip -c > {params.sorted_bed}
                            tabix -p bed {params.sorted_bed}
                            {config[STRELKA_DIR]}bin/configureStrelkaGermlineWorkflow.py --bam {input[0]} --referenceFasta {input[2]} --runDir {params.out_dir}/{params.sample}/strelka --callRegions {params.sorted_bed}
                            {params.out_dir}{params.sample}/strelka/runWorkflow.py -j {config[NUMBER_CPU]} -m local
                            mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz {output.variant_results_file_unfiltered}
                            mv {params.out_dir}{params.sample}/strelka/results/variants/genome.S1.vcf.gz.tbi {output.variant_results_file_unfiltered_index}
                            """)

rule variantannotation:
    input:
        rules.variantcalling.output.variant_results_file
    output:
        annotated_variant_results_file = results_dir + "{sample}/{sample}_SNPindel_annotated.vcf.gz",
        annotated_variant_results_file_index = results_dir + "{sample}/{sample}_SNPindel_annotated.vcf.gz.tbi",
        annotated_variant_results_text = results_dir + "{sample}/{sample}_SNPindel_annotated.txt"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        ref_version = annovar_ref_version,
        operations = annovar_operations,
        protocols = annovar_protocols,
        annotation = {config[ANNOTATION]},
        variantcalling = {config[SNP_INDEL]},
    log:
        log_dir + "variantannotation.log"
    resources:
        mem_mb = memory
    run:
        if params.variantcalling == "true" and params.annotation == "true":
            shell("""
            perl {config[ANNOVAR_DIR]}table_annovar.pl --thread {config[NUMBER_CPU]} --vcfinput {input[0]} {config[ANNOVAR_DB]} -buildver {params.ref_version} -remove -protocol {params.protocols} -operation {params.operations} -nastring . --outfile {params.out_dir}{params.sample}/{sample}_annovar_SNPindel.vcf
            mv {params.out_dir}{params.sample}/{sample}_annovar_SNPindel.vcf.{params.ref_version}_multianno.vcf {params.out_dir}{params.sample}/{params.sample}_SNPindel_annotated.vcf
            mv {params.out_dir}{params.sample}/annovar_SNPindel.vcf.{params.ref_version}_multianno.txt {output.annotated_variant_results_text}
            bgzip -f {params.out_dir}{params.sample}/{params.sample}_SNPindel_annotated.vcf ; tabix -fp vcf {params.out_dir}{params.sample}/{params.sample}_SNPindel_annotated.vcf.gz
            """)

rule expansion:
    input:
        bam_file,
        path_reference
    output:
        expansion_file = results_dir + "{sample}/{sample}_expansions.vcf.gz",
        expansion_file_index = results_dir + "{sample}/{sample}_expansions.vcf.gz.tbi"
    conda:
        "envs/variantcalling.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        variant_catalog = path_expansionHunter_catalog,
        expansion = {config[EXPANSION]}
    log:
        log_dir + "expansion.log"
    resources:
        mem_mb = memory
    run:
        if params.expansion == "true":
            shell("""
            ExpansionHunter --reads {input[0]} --reference {input[1]} --variant-catalog {params.variant_catalog} --output-prefix {params.out_dir}{params.sample}_expansions
            bgzip {params.out_dir}{params.sample}_expansions.vcf
            tabix -p vcf {output.expansion_file}
            """)

rule expansionannotation:
    input:
        rules.expansion.output.expansion_file
    output:
        annotated_expansion_file = results_dir + "{sample}/{sample}_expansions_annotated.vcf.gz",
        annotated_expansion_file_index = results_dir + "{sample}/{sample}_expansions_annotated.vcf.gz.tbi"
    conda:
        "envs/annotation.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        ref_version = annovar_ref_version,
        operations = annovar_operations,
        protocols = annovar_protocols,
        expansion = {config[EXPANSION]},
        annotation = {config[ANNOTATION]}
    log:
        log_dir + "expansionannotation.log"
    resources:
        mem_mb = memory
    run:
        if params.expansion == "true" and params.annotation == "true":
            shell("""
            perl {config[ANNOVAR_DIR]}table_annovar.pl --thread {config[NUMBER_CPU]} --vcfinput {input[0]} {config[ANNOVAR_DB]} -buildver {params.ref_version} -remove -protocol {params.protocols} -operation {params.operations} -nastring . --outfile {params.out_dir}{params.sample}/annovar_expansions.vcf
            mv {params.out_dir}{params.sample}/annovar_expansions.vcf.{params.ref_version}_multianno.vcf {params.out_dir}{params.sample}/{params.sample}_expansions_annotated.vcf
            bgzip -f {params.out_dir}{params.sample}/{params.sample}_expansions_annotated.vcf ; tabix -fp vcf {params.out_dir}{params.sample}/{params.sample}_expansions_annotated.vcf.gz
            """)

rule STRprofile:
    input:
        bam_file,
        path_reference
    output:
        STR_profile = results_dir + "{sample}/{sample}_expansiondenovo.str_profile.json",
        genotypeSTR_input = results_dir + "{sample}/{sample}_genotypeSTRinput.txt"
    conda:
        "envs/variantcalling.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        STR = {config[SHORT_TANDEM_REPEAT]}
    log:
        log_dir + "STRprofile.log"
    resources:
        mem_mb = memory
    run:
        if params.STR == "true":
            shell("""
            {config[EXPANSIONHUNTERDENOVO_DIR]}bin/ExpansionHunterDenovo profile --reads {input[0]} --reference {input[1]} --output-prefix {params.out_dir}{params.sample}/{params.sample}_expansiondenovo --min-anchor-mapq 50 --max-irr-mapq 40 --log-reads
            cat {params.out_dir}{params.sample}/{params.sample}_expansiondenovo.locus.tsv | sed 's/contig/chr/g' | cut -f1-4 > {output.genotypeSTR_input}
            """)

rule genotypeSTR:
    input:
        rules.STRprofile.output.genotypeSTR_input,
        path_reference,
        bam_file
    output:
        EHDN_variant_catalog = results_dir + "{sample}/{sample}_EHDN_variant_catalog.json",
        EHDN_expansion_file = results_dir + "{sample}/{sample}_EHDNexpansions.vcf.gz",
        EHDN_expansion_file_index = results_dir + "{sample}/{sample}_EHDNexpansions.vcf.gz.tbi"
    conda:
        "envs/variantcalling.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        STR = {config[SHORT_TANDEM_REPEAT]},
        genotype = {config[genotype_SHORT_TANDEM_REPEAT]},
        EHDN_excluded = results_dir + "{sample}/{sample}_EHDN_excluded.csv",
        EHDN_unmatched = results_dir + "{sample}/{sample}_EHDN_unmatched.csv"
    log:
        log_dir + "genotypeSTR.log"
    resources:
        mem_mb = memory
    run:
        if params.STR == "true" and params.genotype == "true":
            shell("""
            python scripts/conversion_EHDN_catalog.py {input[0]} {input[1]} {output.EHDN_variant_catalog} {params.EHDN_unmatched} {params.EHDN_excluded}
            ExpansionHunter --reads {input[2]} --reference {input[1]} --variant-catalog {output.EHDN_variant_catalog} --output-prefix {params.out_dir}{params.sample}_EHDNexpansions
            bgzip {params.out_dir}{params.sample}_EHDNexpansions.vcf
            tabix -p vcf {output.EHDN_expansion_file}
            """)

rule STRannotation:
    input:
        rules.genotypeSTR.output.EHDN_expansion_file
    output:
        annotated_EHDN_expansion_file = results_dir + "{sample}/{sample}_STR_annotated.vcf.gz",
        annotated_EHDN_expansion_file_index = results_dir + "{sample}/{sample}_STR_annotated.vcf.gz.tbi"
    conda:
        "envs/annotation.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        STR = {config[SHORT_TANDEM_REPEAT]},
        genotype = {config[genotype_SHORT_TANDEM_REPEAT]},
        annotation = {config[ANNOTATION]},
        ref_version = annovar_ref_version,
        protocols = annovar_protocols,
        operations = annovar_operations
    log:
        log_dir + "STRannotation.log"
    resources:
        mem_mb = memory
    run:
        if (params.STR and params.genotype and params.annotation) == "true":
            shell("""
            perl {config[ANNOVAR_DIR]}table_annovar.pl --thread {config[NUMBER_CPU]} --vcfinput {input[0]} {config[ANNOVAR_DB]} -buildver {params.ref_version} -remove -protocol {params.protocols} -operation {params.operations} -nastring . --outfile {params.out_dir}{params.sample}/annovar_EHDNexpansions.vcf
            mv {params.out_dir}{params.sample}/annovar_EHDNexpansions.vcf.{params.ref_version}_multianno.vcf {params.out_dir}{params.sample}/{params.sample}_STR_annotated.vcf
            bgzip -f {params.out_dir}{params.sample}/{params.sample}_STR_annotated.vcf ; tabix -fp vcf {output.annotated_EHDN_expansion_file}
            """)

rule CramToBam:
    input:
        path_reference,
        input_file = input_dir + "{sample}.cram"
    output:
        delly_bam = results_dir + "{sample}/{sample}_delly.bam",
        delly_bam_index = results_dir + "{sample}/{sample}_delly.bam.bai"
    params:
        SV = {config[STRUCTURAL_VARIANT]},
        format = {config[FORMAT]},
        out_dir = results_dir,
        sample = "{sample}"
    conda:
        "envs/samtools.yaml"
    log:
        log_dir + "cramtobam.log"
    resources:
        mem_mb = memory
    run:
        if params.SV == "true" and params.format == "cram":
            shell("""
            samtools view -b -h -@ {config[NUMBER_CPU]} -T {input[0]} -o {output.delly_bam} {input.input_file}
            samtools index -@ {config[NUMBER_CPU]} {output.delly_bam}
            """)

            bam_file = params.out_dir + params.sample/params.sample_delly.bam

rule SV:
    input:
        bam_file,
        path_reference,
        path_bed
    output:
        manta_SV = results_dir + "{sample}/{sample}_manta_SV.vcf",
        delly_SV = results_dir + "{sample}/{sample}_delly_SV.vcf",
        merged_SV = results_dir + "{sample}/{sample}_merged_SV.vcf.gz",
        merged_SV_index = results_dir + "{sample}/{sample}_merged_SV.vcf.gz.tbi"
    conda:
        "envs/variantcalling.yaml"
    params:
        temp_bed = results_dir + "{sample}/temp.bed.gz",
        sorted_bed = results_dir + "{sample}/sorted.bed.gz",
        out_dir = results_dir,
        sample = "{sample}",
        delly_exclude_regions = path_delly_exclude_regions,
        paired = {config[PAIRED]},
        use_bed = {config[USE_BED]},
    log:
        log_dir + "SVwithBED.log"
    resources:
        mem_mb = memory
    run:
        if params.SV == "true" and params.paired == "paired":
            if params.use_bed == "true":
                shell("""
                bgzip -c {input[2]} > {params.temp_bed}
                sortBed -i {params.temp_bed} | bgzip -c > {params.sorted_bed}
                tabix -p bed {params.sorted_bed}
                {config[MANTA_DIR]}bin/configManta.py --bam {input[0]} --referenceFasta {input[1]} --runDir {params.out_dir}{params.sample}/SV_manta --callRegions {params.sorted_bed}
                {params.out_dir}{params.sample}SV_manta/runWorkflow.py -j {config[NUMBER_CPU]} -m local
                mv {params.out_dir}{params.sample}/SV_manta/results/variants/diploidSV.vcf.gz {params.out_dir}{params.sample}/{params.sample}_SV_manta.vcf.gz
                gzip -d {params.out_dir}{params.sample}/{params.sample}_SV_manta.vcf.gz
                rm -r {params.out_dir}{params.sample}/SV_manta
                delly call -g {input[1]} -o {params.out_dir}{params.sample}/{params.sample}_delly_SV.bcf -x {params.delly_exclude_regions} {input[0]}
                bcftools view {params.out_dir}{params.sample}/{params.sample}_delly_SV.bcf > {output.delly_SV}
                ls {params.out_dir}{params.sample}/*SV.vcf > {params.out_dir}{params.sample}/survivor_sample_files
                SURVIVOR merge {params.out_dir}{params.sample}/survivor_sample_files 1000 1 1 1 0 30 {params.out_dir}{params.sample}/{params.sample}_merged_SV.vcf
                perl scripts/vcf-sort.pl {params.out_dir}{params.sample}/{params.sample}_merged_SV.vcf | bgzip -c > {output.merged_SV}
                tabix -p vcf {output.merged_SV}
                rm {params.out_dir}{params.sample}/survivor_sample_files {params.out_dir}{params.sample}/{params.sample}_delly_SV.bcf {params.out_dir}{params.sample}/{params.sample}_delly_SV.bcf.csi {params.out_dir}{params.sample}/{params.sample}_merged_SV.vcf
                """)

            else:
                shell("""
                {config[MANTA_DIR]}bin/configManta.py --bam {input[0]} --referenceFasta {input[1]} --runDir {params.out_dir}{params.sample}/SV_manta
                {params.out_dir}{params.sample}SV_manta/runWorkflow.py -j {config[NUMBER_CPU]} -m local
                mv {params.out_dir}{params.sample}/SV_manta/results/variants/diploidSV.vcf.gz {params.out_dir}{params.sample}/{params.sample}_SV_manta.vcf.gz
                gzip -d {params.out_dir}{params.sample}/{params.sample}_SV_manta.vcf.gz
                rm -r {params.out_dir}{params.sample}/SV_manta
                delly call -g {input[1]} -o {params.out_dir}{params.sample}/{params.sample}_delly_SV.bcf -x {params.delly_exclude_regions} {input[0]}
                bcftools view {params.out_dir}{params.sample}/{params.sample}_delly_SV.bcf > {output.delly_SV}
                ls {params.out_dir}{params.sample}/*SV.vcf > {params.out_dir}{params.sample}/survivor_sample_files
                {config[SURVIVOR_DIR]}SURVIVOR merge {params.out_dir}{params.sample}/survivor_sample_files 1000 1 1 1 0 30 {params.out_dir}{params.sample}/{params.sample}_merged_SV.vcf
                perl scripts/vcf-sort.pl {params.out_dir}{params.sample}/{params.sample}_merged_SV.vcf | bgzip -c > {output.merged_SV}
                tabix -p vcf {output.merged_SV}
                rm {params.out_dir}{params.sample}/survivor_sample_files {params.out_dir}{params.sample}/{params.sample}_delly_SV.bcf {params.out_dir}{params.sample}/{params.sample}_delly_SV.bcf.csi {params.out_dir}{params.sample}/{params.sample}_merged_SV.vcf
                """)

rule SVannotation:
    input:
        rules.SV.output.merged_SV,
    output:
        SV_annotation_file = results_dir + "{sample}/{sample}_SV_annotated.tsv"
    conda:
        "envs/SVannotation.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        genomebuild = annotsv_ref_version,
        alsgenescanner = {config[ALSGENESCANNER]},
        annotation = {config[ANNOTATION]},
        SV = {config[STRUCTURAL_VARIANT]}
    log:
        log_dir + "SVannotation.log"
    resources:
        mem_mb = memory
    run:
        if params.SV == "true" and params.annotation == "true":
            if params.alsgenescanner == "true":
                shell("""
                cpan YAML::XS
                cpan Sort::Key::Natural
                export ANNOTSV={config[ANNOTSV_DIR]}
                {config[ANNOTSV_DIR]}bin/AnnotSV -annotationsDir {config[ANNOTSV_DIR]}/share/AnnotSV -SVinputFile {input[0]} -genomeBuild {params.genomebuild} -candidateGenesFiltering yes -candidateGenesFile resources/alsgenescanner/list_genes_all.txt outputDir {params.out_dir}{params.sample} -outputFile {params.sample}_SV_annotated -SVminSize 30 {config[ANNOTSV_CUSTOM_OPTIONS]}
                """)
            else:
                shell("""
                cpan YAML::XS
                cpan Sort::Key::Natural
                export ANNOTSV={config[ANNOTSV_DIR]}
                {config[ANNOTSV_DIR]}bin/AnnotSV -annotationsDir {config[ANNOTSV_DIR]}/share/AnnotSV -SVinputFile {input[0]} -genomeBuild {params.genomebuild} outputDir {params.out_dir}{params.sample} -outputFile {params.sample}_SV_annotated -SVminSize 30 {config[ANNOTSV_CUSTOM_OPTIONS]}
                """)

rule MEI:
    input:
        bam_file,
        path_reference,
        melt_bed
    output:
        MEI_file = results_dir + "{sample}/{sample}_MEI.vcf.gz",
        MEI_file_index = results_dir + "{sample}/{sample}_MEI.vcf.gz.tbi"
    conda:
        "envs/MEI.yaml"
    params:
        out_dir = results_dir,
        sample="{sample}",
        zipped = melt_zipped_files,
        transposon_list = path_melt + "transposon_reference.list",
        removal_dir=bam_file,
        exome = {config[EXOME]},
        MEI = {config[MOBILE_ELEMENT_INSERTION]}
    log:
        log_dir + "MEI.log"
    resources:
        mem_mb = memory
    run:
        if params.MEI == "true":
            shell("""
            mkdir {params.out_dir}/{params.sample}/melt
            ls {params[2]} | sed 's/\*//g' > {params.transposon_list}
            java -Xmx{config[MEM_GB]}G -jar {config[MELT_DIR]}MELT.jar Single -bamfile {input[0]} -h {input[1]} -t {params.transposon_list} -n {input[2]} -w {params.out_dir}/{params.sample}/melt {config[MELT_CUSTOM_OPTIONS]}
            cat {params.out_dir}/{params.sample}/melt/SVA.final_comp.vcf | grep '^#' > {params.out_dir}/{params.sample}/melt/{params.sample}.header.txt
            cat {params.out_dir}/{params.sample}/melt/SVA.final_comp.vcf | grep -v '^#' > {params.out_dir}/{params.sample}/melt/{params.sample}.sva.vcf
            cat {params.out_dir}/{params.sample}/melt/LINE1.final_comp.vcf | grep -v '^#' > {params.out_dir}/{params.sample}/melt/{params.sample}.line1.vcf
            cat {params.out_dir}/{params.sample}/melt/ALU.final_comp.vcf | grep -v '^#' > {params.out_dir}/{params.sample}/melt/{params.sample}.alu.vcf                    cat {params.out_dir}/{params.sample}/melt/{params.sample}.header.txt {params.out_dir}/{params.sample}/melt/{params.sample}.sva.vcf {params.out_dir}/{params.sample}/melt/{params.sample}.line1.vcf {params.out_dir}/{params.sample}/melt/{params.sample}.alu.vcf | perl scripts/vcf-sort.pl -c | bgzip -c > {output.MEI_file}
            tabix -p vcf {output.MEI_file}
            rm -r {params.out_dir}/{params.sample}/melt
            rm {params.removal_dir}.disc {params.removal_dir}.disc.bai {params.removal_dir}.fq
            """)

            if params.exome == "true":
                shell("""
                mkdir {params.out_dir}/{params.sample}/melt
                ls {params[2]} | sed 's/\*//g' > {params.transposon_list}
                java -Xmx{config[MEM_GB]}G -jar {config[MELT_DIR]}MELT.jar Single -bamfile {input[0]} -h {input[1]} -t {params.transposon_list} -n {input[2]} -w {params.out_dir}/{params.sample}/melt -exome {config[MELT_CUSTOM_OPTIONS]}
                cat {params.out_dir}/{params.sample}/melt/SVA.final_comp.vcf | grep '^#' > {params.out_dir}/{params.sample}/melt/{params.sample}.header.txt
                cat {params.out_dir}/{params.sample}/melt/SVA.final_comp.vcf | grep -v '^#' > {params.out_dir}/{params.sample}/melt/{params.sample}.sva.vcf
                cat {params.out_dir}/{params.sample}/melt/LINE1.final_comp.vcf | grep -v '^#' > {params.out_dir}/{params.sample}/melt/{params.sample}.line1.vcf
                cat {params.out_dir}/{params.sample}/melt/ALU.final_comp.vcf | grep -v '^#' > {params.out_dir}/{params.sample}/melt/{params.sample}.alu.vcf
                cat {params.out_dir}/{params.sample}/melt/{params.sample}.header.txt {params.out_dir}/{params.sample}/melt/{params.sample}.sva.vcf {params.out_dir}/{params.sample}/melt/{params.sample}.line1.vcf {params.out_dir}/{params.sample}/melt/{params.sample}.alu.vcf | perl scripts/vcf-sort.pl -c | bgzip -c > {output.MEI_file}
                tabix -p vcf {output.MEI_file}
                rm -r {params.out_dir}/{params.sample}/melt
                rm {params.removal_dir}.disc {params.removal_dir}.disc.bai {params.removal_dir}.fq
                """)

rule MEIannotation:
    input:
        rules.MEI.output.MEI_file,
    output:
        MEI_annotation_file = results_dir + "{sample}/{sample}_MEI_annotated.tsv"
    conda:
        "envs/SVannotation.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        genomebuild = annotsv_ref_version,
        alsgenescanner = {config[ALSGENESCANNER]},
        MEI = {config[MOBILE_ELEMENT_INSERTION]},
        annotation = {config[ANNOTATION]}
    log:
        log_dir + "MEIannotation.log"
    resources:
        mem_mb = memory
    run:
        if params.MEI == "true" and params.annotation == "true":
            if params.alsgenescanner == "true":
                shell("""
                cpan YAML::XS
                cpan Sort::Key::Natural
                export ANNOTSV={config[ANNOTSV_DIR]}
                {config[ANNOTSV_DIR]}bin/AnnotSV -annotationsDir {config[ANNOTSV_DIR]}/share/AnnotSV -SVinputFile {input[0]} -genomeBuild {params.genomebuild} -candidateGenesFiltering yes -candidateGenesFile resources/alsgenescanner/list_genes_all.txt outputDir {params.out_dir}{params.sample} -outputFile {params.sample}_MEI_annotated -SVminSize 30 {config[ANNOTSV_CUSTOM_OPTIONS]}
                """)
            else:
                shell("""
                cpan YAML::XS
                cpan Sort::Key::Natural
                export ANNOTSV={config[ANNOTSV_DIR]}
                {config[ANNOTSV_DIR]}bin/AnnotSV -annotationsDir {config[ANNOTSV_DIR]}/share/AnnotSV -SVinputFile {input[0]} -genomeBuild {params.genomebuild} outputDir {params.out_dir}{params.sample} -outputFile {params.sample}_MEI_annotated -SVminSize 30 {config[ANNOTSV_CUSTOM_OPTIONS]}
                """)

rule SVandMEImergingandannotation:
    input:
        rules.SV.output.merged_SV,
        rules.MEI.output.MEI_file
    output:
        merged_SV_MEI = results_dir + "{sample}/{sample}_SV_MEI.merged.vcf.gz",
        merged_SV_MEI_index = results_dir + "{sample}/{sample}_SV_MEI.merged.vcf.gz.tbi"
    conda:
        "envs/variantcalling.yaml"
    params:
        merged_dir = results_dir + "{sample}/merging",
        out_dir = results_dir,
        sample = "{sample}",
        SV_vcf = results_dir + "{sample}/merging/{sample}_merged_SV.vcf",
        MEI_vcf = results_dir + "{sample}/merging/{sample}_MEI.vcf",
        SV = {config[STRUCTURAL_VARIANT]},
        MEI = {config[MOBILE_ELEMENT_INSERTION]},
        annotation = {config[ANNOTATION]},
        alsgenescanner = {config[ALSGENESCANNER]},
        genomebuild = annotsv_ref_version
    log:
        log_dir + "SVandMEImerging.log"
    resources:
        mem_mb = memory
    run:
        if params.SV == "true" and params.MEI == "true":
            shell("""
            mkdir {params.merged_dir}
            bgzip -d {input[0]} > {params.SV_vcf}
            bgzip -d {input[1]} > {params.MEI_vcf}
            ls {params.merged_dir}*.vcf > {params.out_dir}{params.sample}survivor_sample_files
            {config[SURVIVOR_DIR]}SURVIVOR merge {params.out_dir}{params.sample}survivor_sample_files 1000 1 1 1 0 30 {params.out_dir}{params.sample}/{params.sample}_SV_MEI.merged.vcf
            perl scripts/vcf-sort.pl {params.out_dir}{params.sample}/{params.sample}_SV_MEI.merged.vcf | bgzip -c > {output.merged_SV_MEI}
            tabix -p vcf {output.merged_SV_MEI}
            rm {params.out_dir}{params.sample}/survivor_sample_files
            """)

            if params.annotation == "true":
                if params.alsgenescanner == "true":
                    shell("""
                    cpan YAML::XS
                    cpan Sort::Key::Natural
                    export ANNOTSV={config[ANNOTSV_DIR]}
                    {config[ANNOTSV_DIR]}bin/AnnotSV -annotationsDir {config[ANNOTSV_DIR]}/share/AnnotSV -SVinputFile {input[0]} -genomeBuild {params.genomebuild} -candidateGenesFiltering yes -candidateGenesFile resources/alsgenescanner/list_genes_all.txt outputDir {params.out_dir}{params.sample} -outputFile {params.sample}_SV_MEI_annotated -SVminSize 30 {custom[ANNOTSV_CUSTOM_OPTIONS]}
                    """)

                else:
                    shell("""
                    cpan YAML::XS
                    cpan Sort::Key::Natural
                    export ANNOTSV={config[ANNOTSV_DIR]}
                    {config[ANNOTSV_DIR]}bin/AnnotSV -annotationsDir {config[ANNOTSV_DIR]}/share/AnnotSV -SVinputFile {input[0]} -genomeBuild {params.genomebuild} outputDir {params.out_dir}{params.sample} -outputFile {params.sample}_SV_MEI_annotated -SVminSize 30 {config[ANNOTSV_CUSTOM_OPTIONS]}
                    """)

rule extractnonhumanreads:
    input:
        bam_file
    output:
        unaligned_fastq = results_dir + "{sample}/unaligned_reads.fastq.gz"
    conda:
        "envs/samtools.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        virus = {config[VIRUS]},
        bacteria = {config[BACTERIA]},
        microbes = {config[CUSTOM_MICROBES]}
    log:
        log_dir + "extractnonhumanreads.log"
    resources:
        mem_mb = memory
    run:
        if (params.virus or params.bacteria or params.microbes) == "true":
            shell("""
            samtools view -@ {config[NUMBER_CPU]} -hf 4 {input[0]} | samtools bam2fq -s {params.out_dir}{params.sample}/singleton_reads.fastq -@ {config[NUMBER_CPU]} - > {params.out_dir}{params.sample}/unaligned_reads.fastq
            cat {params.out_dir}{params.sample}/singleton_reads.fastq >> {params.out_dir}{params.sample}/unaligned_reads.fastq ; gzip {params.out_dir}{params.sample}/unaligned_reads.fastq
            """)

rule identifyviralmaterial:
    input:
        rules.extractnonhumanreads.output.unaligned_fastq,
    output:
        virus_stats = results_dir + "{sample}/{sample}_virus_stats.txt",
        virus_report = reports_dir + "{sample}/{sample}_virus_report.txt"
    conda:
        "envs/alignmentfast.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        virus = {config[VIRUS]}
    log:
        log_dir + "identifyvirus.log"
    resources:
        mem_mb = memory
    run:
        if params.virus == "true":
            shell("""
            hisat2 --no-spliced-alignment -p {config[NUMBER_CPU]} -x {config[VIRUS_INDEX]} -U {input[0]} | samtools view -@ {config[NUMBER_CPU]} -hSb - | samtools sort -@ {config[NUMBER_CPU]} -T {params.out_dir}{params.sample}tempvirus.file -o {params.out_dir}{params.sample}/{params.sample}_output_virus.bam -
            samtools index -@ {config[NUMBER_CPU]} {params.out_dir}{params.sample}/{params.sample}_output_virus.bam ; samtools idxstats {params.out_dir}{params.sample}/{params.sample}_output_virus.bam > {output.virus_stats}
            python scripts/non_human_reads_report.py {output.virus_stats} {params.out_dir}{params.sample}/{params.sample}_virus_stats.list {params.out_dir}{params.sample}/{params.sample}_output_virus.bam {params.out_dir}{params.sample}/{params.sample}_virus_coverage_stats.txt {output.virus_report}
            """)

rule identifybacterialmaterial:
    input:
        rules.extractnonhumanreads.output.unaligned_fastq,
    output:
        bacteria_stats = results_dir + "{sample}/{sample}_bacteria_stats.txt",
        bacteria_report = reports_dir + "{sample}/{sample}_bacteria_report.txt"
    conda:
        "envs/alignmentfast.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        bacteria = {config[BACTERIA]}
    log:
        log_dir + "identifybacteria.log"
    resources:
        mem_mb = memory
    run:
        if params.bacteria == "true":
            shell("""
            hisat2 --no-spliced-alignment -p {config[NUMBER_CPU]} -x {config[BACTERIA_INDEX]} -U {input[0]} | samtools view -@ {config[NUMBER_CPU]} -hSb - | samtools sort -@ {config[NUMBER_CPU]} -T {params.out_dir}{params.sample}tempbacteria.file -o {params.out_dir}{params.sample}/{params.sample}_output_bacteria.bam -
            samtools index -@ {config[NUMBER_CPU]} {params.out_dir}{params.sample}/{params.sample}_output_bacteria.bam ; samtools idxstats {params.out_dir}{params.sample}/{params.sample}_output_bacteria.bam > {output.bacteria_stats}
            python scripts/non_human_reads_report.py {output.bacteria_stats} {params.out_dir}{params.sample}/{params.sample}_bacteria_stats.list {params.out_dir}{params.sample}/{params.sample}_output_bacteria.bam {params.out_dir}{params.sample}/{params.sample}_bacteria_coverage_stats.txt {output.bacteria_report}
            """)

rule identifycustommaterial:
    input:
        rules.extractnonhumanreads.output.unaligned_fastq,
    output:
        microbes_stats = results_dir + "{sample}/{sample}_microbes_stats.txt",
        microbes_report = reports_dir + "{sample}/{sample}_microbes_report.txt"
    conda:
        "envs/alignmentfast.yaml"
    params:
        out_dir = results_dir,
        sample = "{sample}",
        microbes = {config[CUSTOM_MICROBES]}
    log:
        log_dir + "identifycustommicrobes.log"
    resources:
        mem_mb = memory
    run:
        if params.microbes == "true":
            shell("""
            hisat2 --no-spliced-alignment -p {config[NUMBER_CPU]} -x {config[CUSTOM_MICROBES_INDEX]} -U {input[0]} | samtools view -@ {config[NUMBER_CPU]} -hSb - | samtools sort -@ {config[NUMBER_CPU]} -T {params.out_dir}{params.sample}tempmicrobes.file -o {params.out_dir}{params.sample}/{params.sample}_output_microbes.bam -
            samtools index -@ {config[NUMBER_CPU]} {params.out_dir}{params.sample}/{params.sample}_output_microbes.bam ; samtools idxstats {params.out_dir}{params.sample}/{params.sample}_output_microbes.bam > {output.microbes_stats}
            python scripts/non_human_reads_report.py {output.micrboes_stats} {params.out_dir}{params.sample}/{params.sample}_microbes_stats.list {params.out_dir}{params.sample}/{params.sample}_output_microbes.bam {params.out_dir}{params.sample}/{params.sample}_microbes_coverage_stats.txt {output.microbes_report}
            """)

rule alignmentreport:
    input:
        bam_file
    output:
        flagstat = reports_dir + "{sample}/{sample}_alignment_flagstat.txt",
        stats = reports_dir + "{sample}/{sample}_alignment_stats.txt"
    conda:
        "envs/simplereports.yaml"
    params:
        alignmentreport = {config[ALIGNMENT_REPORT]}
    log:
        log_dir + "alignmentreport.log"
    resources:
        mem_mb = memory
    run:
        if params.alignmentreport == "true":
            shell("""
            samtools flagstat -@ {config[NUMBER_CPU]} {input[0]} > {output.flagstat}
            samtools stats -@ {config[NUMBER_CPU]} {input[0]} > {output.stats}
            """)

rule sequencingreport:
    input:
        input_file,
        input_file2
    output:
        fastqc_report = reports_dir + "{sample}/{sample}_sequencing_report.txt"
    conda:
        "envs/simplereports.yaml"
    params:
        out_dir = reports_dir,
        sequencingreport = {config[SEQUENCING_REPORT]},
        format = {config[FORMAT]}
    log:
        log_dir + "sequencingreport.log"
    resources:
        mem_mb = memory
    run:
        if params.sequencingreport == "true" and params.format == "fastq":
            shell("""
            fastqc -o {params.out_dir} -f fastq -t {config[NUMBER_CPU]} {input[0]} {input[1]}
            """)

rule callsreport:
    input:
        rules.variantcalling.output.variant_results_file
    output:
        vcfstats = reports_dir + "{sample}/{sample}_calls_vcfstats.txt"
    conda:
        "envs/simplereports.yaml"
    params:
        out_dir = reports_dir,
        sample = "{sample}",
        callsreport = {config[SNP_INDEL_CALLS_REPORT]},
        variantcalling = {config[SNP_INDEL]}
    log:
        log_dir + "callsreport.log"
    resources:
        mem_mb = memory
    run:
        if params.callsreport == "true" and params.variantcalling == "true":
            shell("""
            bcftools stats --threads {config[NUMBER_CPU]} {input[0]} > {output.vcfstats}
            """)

rule multireport:
    input:
        reports_dir
    conda:
        "envs/simplereports.yaml"
    output:
        reports_dir + "multiqc_report.html"
    params:
        alignmentreport = {config[ALIGNMENT_REPORT]},
        sequencingreport = {config[SEQUENCING_REPORT]},
        callsreport = {config[SNP_INDEL_CALLS_REPORT]}
    log:
        log_dir + "multireport.log"
    resources:
        mem_mb = memory
    run:
        if (params.alignmentreport or params.sequencingreport or params.callsreport) == "true":
            shell("""
            multiqc -o {input[0]} {input[0]}
            """)

rule variantresultsreport:
    input:
        rules.variantannotation.output.annotated_variant_results_file,
        path_gene_list
    output:
        SNPindel_annotation_report = reports_dir + "{sample}/{sample}_annovar_SNPindel.txt",
        variant_annotation_file_zipped = results_dir + "{sample}/{sample}_SNPindel_annotated.vcf.gz",
        variant_annotation_file_zipped_index = results_dir + "{sample}/{sample}_SNPindel_annotated.vcf.gz.tbi"
    conda:
        "envs/AGS.yaml"
    params:
        out_dir = reports_dir,
        results = results_dir,
        sample = "{sample}",
        annotation = {config[ANNOTATION]},
        resultsreport = {config[ANNOTATION_RESULTS_REPORT]},
        variantcalling = {config[SNP_INDEL]}
    log:
        log_dir + "variantannotationreport.log"
    resources:
        mem_mb = memory
    run:
        if (params.variantcalling and params.annotation and params.resultsreport) == "true":
            shell("""
            gzip -d {input[0]}
            python scripts/simpleannotationreport.py {params.results}{params.sample}/{params.sample}_SNPindel_annotated.vcf {input[1]} {output.SNPindel_annotation_report}
            bgzip {params.results}{params.sample}/{params.sample}_SNPindel_annotated.vcf
            tabix -p vcf {output.variant_annotation_file_zipped}
            """)

rule expansionresultsreport:
    input:
        rules.expansionannotation.output.annotated_expansion_file,
        path_gene_list
    output:
        expansion_annotation_report = reports_dir + "{sample}/{sample}_annovar_expansions.txt",
        expansion_annotation_file_zipped = results_dir + "{sample}/{sample}_expansions_annotated.vcf.gz",
        expansion_annotation_file_zipped_index = results_dir + "{sample}/{sample}_expansions_annotated.vcf.gz.tbi"
    conda:
        "envs/AGS.yaml"
    params:
        out_dir = reports_dir,
        results = results_dir,
        sample = "{sample}",
        annotation = {config[ANNOTATION]},
        resultsreport = {config[ANNOTATION_RESULTS_REPORT]},
        expansion = {config[EXPANSION]}
    log:
        log_dir + "expansionannotationreport.log"
    resources:
        mem_mb = memory
    run:
        if (params.expansion and params.annotation and params.resultsreport) == "true":
            shell("""
            gzip -d {input[0]}
            python scripts/simpleannotationreport.py {params.results}{params.sample}/{params.sample}_expansions_annotated.vcf {input[1]} {output.expansion_annotation_report}
            bgzip {params.results}{params.sample}/{params.sample}_expansions_annotated.vcf
            tabix -p vcf {output.expansion_annotation_file_zipped}
            """)

rule STRresultsreport:
    input:
        rules.STRannotation.output.annotated_EHDN_expansion_file,
        path_gene_list
    output:
        STR_annotation_report = reports_dir + "{sample}/{sample}_annovar_STR.txt",
        STR_annotation_file_zipped = results_dir + "{sample}/{sample}_EHDNexpansions_annotated.vcf.gz",
        STR_annotation_file_zipped_index = results_dir + "{sample}/{sample}_EHDNexpansions_annotated.vcf.gz.tbi"
    conda:
        "envs/AGS.yaml"
    params:
        out_dir = reports_dir,
        results = results_dir,
        sample = "{sample}",
        annotation = {config[ANNOTATION]},
        resultsreport = {config[ANNOTATION_RESULTS_REPORT]},
        genotype = {config[genotype_SHORT_TANDEM_REPEAT]}
    log:
        log_dir + "STRannotationreport.log"
    resources:
        mem_mb = memory
    run:
        if (params.genotype and params.annotation and params.resultsreport) == "true":
            shell("""
            gzip -d {input[0]}
            python scripts/simpleannotationreport.py {params.results}{params.sample}/{params.sample}_STR_annotated.vcf {input[1]} {output.STR_annotation_report}
            bgzip {params.results}{params.sample}/{params.sample}_STR_annotated.vcf
            tabix -p vcf {output.STR_annotation_file_zipped}
            """)

rule SVandMEIreport:
    input:
        rules.SVMEIannotation.output.SV_MEI_annotation_file
    output:
        SV_MEI_report = reports_dir + "{sample}/{sample}_SV_MEI_annotated.html"
    conda:
        "envs/SVannotation.yaml"
    params:
        out_dir = reports_dir,
        sample = "{sample}",
        ref_version = annovar_ref_version,
        SV = {config[STRUCTURAL_VARIANT]},
        MEI = {config[MOBILE_ELEMENT_INSERTION]},
        resultsreport = {config[ANNOTATION_RESULTS_REPORT]},
        annotation = {config[ANNOTATION]}
    log:
        log_dir + "SVMEIreport.log"
    resources:
        mem_mb = memory
    run:
        if (params.SV and params.MEI and params.annotation and params.resultsreport) == "true":
            shell("""
            cpan YAML::XS
            cpan Sort::Key::Natural
            export ANNOTSV={config[ANNOTSV_DIR]}
            perl {config[KNOTANNOTSV_DIR]}knotAnnotSV.pl --configFile {config[KNOTANNOTSV_DIR]}config_AnnotSV.yaml --annotSVfile {input[0]} --outDir {params.out_dir} --genomeBuild {params.ref_version}
            """)

rule SVreport:
    input:
        rules.SVannotation.output.SV_annotation_file
    output:
        SV_report = reports_dir + "{sample}/{sample}_SV_annotated.html"
    conda:
        "envs/SVannotation.yaml"
    params:
        out_dir = reports_dir,
        sample = "{sample}",
        ref_version = annovar_ref_version,
        SV = {config[STRUCTURAL_VARIANT]},
        resultsreport = {config[ANNOTATION_RESULTS_REPORT]},
        annotation = {config[ANNOTATION]}
    log:
        log_dir + "SVreport.log"
    resources:
        mem_mb = memory
    run:
        if (params.SV and params.annotation and params.resultsreport) == "true":
            shell("""
            cpan YAML::XS
            cpan Sort::Key::Natural
            export ANNOTSV={config[ANNOTSV_DIR]}
            perl {config[KNOTANNOTSV_DIR]}knotAnnotSV.pl --configFile {config[KNOTANNOTSV_DIR]}config_AnnotSV.yaml --annotSVfile {input[0]} --outDir {params.out_dir} --genomeBuild {params.ref_version}
            """)

rule MEIreport:
    input:
        rules.MEIannotation.output.MEI_annotation_file
    output:
        MEI_report = reports_dir + "{sample}/{sample}_MEI_annotated.html"
    conda:
        "envs/SVannotation.yaml"
    params:
        out_dir = reports_dir,
        sample = "{sample}",
        ref_version = annovar_ref_version,
        MEI = {config[MOBILE_ELEMENT_INSERTION]},
        resultsreport = {config[ANNOTATION_RESULTS_REPORT]},
        annotation = {config[ANNOTATION]}
    log:
        log_dir + "MEIreport.log"
    resources:
        mem_mb = memory
    run:
        if (params.MEI and params.annotation and params.resultsreport) == "true":
            shell("""
            cpan YAML::XS
            cpan Sort::Key::Natural
            export ANNOTSV={config[ANNOTSV_DIR]}
            perl {config[KNOTANNOTSV_DIR]}knotAnnotSV.pl --configFile {config[KNOTANNOTSV_DIR]}config_AnnotSV.yaml --annotSVfile {input[0]} --outDir {params.out_dir} --genomeBuild {params.ref_version}
            """)

#rule conciseresultsreport: #need to figure out how to do this - via the else[] thing

rule runAGS:
    input:
        rules.variantannotation.output.annotated_variant_results_text
    output:
        alsgenescanner_all = reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_all.txt",
        alsgenescanner_alsod = reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_alsod.txt",
        alsgenescanner_clinvar = reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_clinvar.txt",
        alsgenescanner_manual_review = reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_manual_review.txt",
        alsgenescanner_ranked = reports_dir + "{sample}/alsgenescanner/{sample}_alsgenescanner_all_ranked.txt"
    conda:
        "envs/AGS.yaml"
    params:
        out_dir = reports_dir,
        alsod_list = "resources/alsgenescanner/list_genes_alsod.txt",
        clinvar_list = "resources/alsgenescanner/list_genes_clinvar.txt",
        review_list = "resources/alsgenescanner/list_genes_manual_review.txt",
        sample = "{sample}",
        variantcalling = {config[SNP_INDEL]},
        alsgenescanner = {config[ALSGENESCANNER]},
        annotation = {config[ANNOTATION]}
    resources:
        mem_mb = memory
    run:
        if (params.variantcalling and params.alsgenescanner and params.annotation) == "true":
            shell("""
            python scripts/alsgenescanner.py {input[0]} {output.alsgenescanner_all}
            python scripts/alsgenescannerreport.py {output.alsgenescanner_all} {output.alsgenescanner_alsod} {params.alsod_list} {output.alsgenescanner_clinvar} {params.clinvar_list} {output.alsgenescanner_manual_review} {params.review_list} {output.alsgenescanner_ranked}
            """)
